use crate::utils;
use cosmian_crypto_base::{
    asymmetric::{ristretto::X25519Crypto, AsymmetricCrypto, KeyPair},
    hybrid_crypto::Kem,
    Error, Key,
};
use rand_core::{CryptoRng, RngCore};
use std::{collections::HashSet, sync::Mutex};

/// CovCrypt private keys are a set of KEM private keys.
pub type PrivateKey = Vec<<<X25519Crypto as AsymmetricCrypto>::KeyPair as KeyPair>::PrivateKey>;

/// CovCrypt public keys are a set of KEM public keys.
pub type PublicKey = Vec<<<X25519Crypto as AsymmetricCrypto>::KeyPair as KeyPair>::PublicKey>;

/// CovCrypt ciphertexts are a list of secret key / encapsulation couples
/// generated by the underlying KEM scheme.
pub type Encapsulation = Vec<(
    <X25519Crypto as Kem>::CipherText,
    <X25519Crypto as Kem>::SecretKey,
)>;

/// CovCrypt secret key is a vector of bytes of the same length as secret key
/// of the underslying KEM.
pub type SecretKey = Vec<u8>;

/// Generate the master private key and master public key of the CoverCrypt scheme.
///
/// - `n`   : number of users
pub fn setup<R: CryptoRng + RngCore>(rng: &Mutex<R>, n: usize) -> (PrivateKey, PublicKey) {
    let (mut msk, mut mpk) = (Vec::with_capacity(n), Vec::with_capacity(n));
    for _ in 0..n {
        let keypair = X25519Crypto::key_gen(rng);
        msk.push(keypair.private_key().to_owned());
        mpk.push(keypair.public_key().to_owned());
    }
    (msk, mpk)
}

/// Generate a user private key for a given list of user groups. It is composed
/// by the list of the KEM private keys associated with the user groups
/// containing the given user ID.
///
/// - `msk` : master secret key
/// - `uid` : user ID
/// - `S`   : list of user groups
pub fn join(msk: &PrivateKey, uid: usize, S: &[HashSet<usize>]) -> PrivateKey {
    S.iter()
        .enumerate()
        .filter_map(|(i, S_i)| {
            if S_i.contains(&uid) {
                Some(msk[i].clone())
            } else {
                None
            }
        })
        .collect()
}

/// Generate the secret key and its encapsulation.
///
/// - `rng` : secure random number generator
/// - `mpk` : master public key
/// - `T`   : target groups
/// - `S`   : user groups
pub fn encaps<R: CryptoRng + RngCore>(
    rng: &Mutex<R>,
    mpk: &PublicKey,
    T: &HashSet<usize>,
    S: &[HashSet<usize>],
) -> Result<(SecretKey, Encapsulation), Error> {
    // secret key
    let K = utils::generate_random_bytes(
        rng,
        <<<X25519Crypto as AsymmetricCrypto>::KeyPair as KeyPair>::PublicKey as Key>::LENGTH,
    );

    // list of targeted user groups
    let A = S
        .iter()
        .enumerate()
        .filter_map(|(i, S_i)| if S_i.is_subset(T) { Some(i) } else { None });

    // construct secret key encapsulation
    let E = A
        .map(
            |i| -> Result<(Vec<u8>, <X25519Crypto as Kem>::CipherText), Error> {
                let (E_i, K_i) = X25519Crypto::encaps(rng, &mpk[i])?;
                Ok((
                    K_i.iter().zip(K.iter()).map(|(e1, e2)| e1 ^ e2).collect(),
                    E_i,
                ))
            },
        )
        .collect::<Result<Vec<(Vec<u8>, <X25519Crypto as Kem>::CipherText)>, Error>>()?;
    Ok((K, E))
}

/// Decapsulate the secret key if the given user ID is in the target set.
///
/// - `uid`     : user ID
/// - `sk_u`    : user private key
/// - `E`       : encapsulation
/// - `T`       : target set
/// - `S`       : list of all user groups
pub fn decaps(
    uid: usize,
    sk_u: &PrivateKey,
    E: &Encapsulation,
    T: &HashSet<usize>,
    S: &[HashSet<usize>],
) -> Result<Option<SecretKey>, Error> {
    if let Some((set_index, key_index)) = utils::get_matching_indexes(uid, T, S) {
        // decapsulate associated secret key
        let K_i = X25519Crypto::decaps(&sk_u[key_index], &E[set_index].1)?;

        // XOR with ciphertext secret key
        let K = K_i
            .iter()
            .zip(E[set_index].0.iter())
            .map(|(e1, e2)| e1 ^ e2)
            .collect();
        Ok(Some(K))
    } else {
        Ok(None)
    }
}
