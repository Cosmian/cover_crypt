use crate::utils;
use cosmian_crypto_base::{
    asymmetric::{ristretto::X25519Crypto, AsymmetricCrypto, KeyPair},
    hybrid_crypto::Kem,
    Error,
};
use rand_core::{CryptoRng, RngCore};
use std::{collections::HashSet, sync::Mutex};

/// CovCrypt private keys are a set of KEM private keys.
pub type PrivateKey = Vec<<<X25519Crypto as AsymmetricCrypto>::KeyPair as KeyPair>::PrivateKey>;

/// CovCrypt public keys are a set of KEM public keys.
pub type PublicKey = Vec<<<X25519Crypto as AsymmetricCrypto>::KeyPair as KeyPair>::PublicKey>;

/// CovCrypt ciphertexts are a list of secret key / encapsulation couples
/// generated by the underlying KEM scheme.
pub type Encapsulation = Vec<(
    <X25519Crypto as Kem>::Encapsulation,
    <X25519Crypto as Kem>::SecretKey,
)>;

/// CovCrypt secret key is a vector of bytes of the same length as secret key
/// of the underslying KEM.
pub type SecretKey = Vec<u8>;

/// Generate the master private key and master public key of the CoverCrypt scheme.
///
/// - `S`   : list of all user groups
pub fn setup<R: CryptoRng + RngCore>(
    rng: &Mutex<R>,
    S: &[HashSet<usize>],
) -> (PrivateKey, PublicKey) {
    let (mut msk, mut mpk) = (Vec::with_capacity(S.len()), Vec::with_capacity(S.len()));
    for _ in S.iter() {
        let keypair = X25519Crypto::key_gen(rng);
        msk.push(keypair.private_key().to_owned());
        mpk.push(keypair.public_key().to_owned());
    }
    (msk, mpk)
}

/// Generate a user private key for a given list of user groups. It is composed
/// by the list of the KEM private keys associated with the user groups
/// containing the given user ID.
///
/// - `msk` : master secret key
/// - `uid` : user ID
/// - `S`   : list of user groups
pub fn join(msk: &PrivateKey, uid: usize, S: &[HashSet<usize>]) -> PrivateKey {
    S.iter()
        .enumerate()
        .filter_map(|(i, S_i)| {
            if S_i.contains(&uid) {
                Some(msk[i].clone())
            } else {
                None
            }
        })
        .collect()
}

/// Generate the secret key and its encapsulation.
///
/// - `rng` : secure random number generator
/// - `mpk` : master public key
/// - `T`   : target groups
/// - `S`   : user groups
pub fn encaps<R: CryptoRng + RngCore>(
    rng: &Mutex<R>,
    mpk: &PublicKey,
    T: &HashSet<usize>,
    S: &[HashSet<usize>],
) -> Result<(SecretKey, Encapsulation), Error> {
    // secret key
    let K = utils::generate_random_bytes(rng, X25519Crypto::KEY_LENGTH);

    // list of targeted user groups
    let A = S
        .iter()
        .enumerate()
        .filter_map(|(i, S_i)| if S_i.is_subset(T) { Some(i) } else { None });

    // construct secret key encapsulation
    let E = A
        .map(
            |i| -> Result<
                (
                    <X25519Crypto as Kem>::SecretKey,
                    <X25519Crypto as Kem>::Encapsulation,
                ),
                Error,
            > {
                let (E_i, K_i) = X25519Crypto::encaps(rng, &mpk[i])?;
                Ok((
                    K_i.iter().zip(K.iter()).map(|(e1, e2)| e1 ^ e2).collect(),
                    E_i,
                ))
            },
        )
        .collect::<Result<Encapsulation, Error>>()?;
    Ok((K, E))
}

/// Decapsulate the secret key if the given user ID is in the target set.
///
/// - `uid`     : user ID
/// - `sk_u`    : user private key
/// - `E`       : encapsulation
/// - `T`       : target set
/// - `S`       : list of all user groups
pub fn decaps(
    uid: usize,
    sk_u: &PrivateKey,
    E: &Encapsulation,
    T: &HashSet<usize>,
    S: &[HashSet<usize>],
) -> Result<Option<SecretKey>, Error> {
    if let Some((set_index, key_index)) = utils::get_matching_indexes(uid, T, S) {
        // decapsulate associated secret key
        let K_i = X25519Crypto::decaps(&sk_u[key_index], &E[set_index].1)?;

        // XOR with ciphertext secret key
        let K = K_i
            .iter()
            .zip(E[set_index].0.iter())
            .map(|(e1, e2)| e1 ^ e2)
            .collect();
        Ok(Some(K))
    } else {
        Ok(None)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use cosmian_crypto_base::entropy::CsRng;
    use eyre::Result;

    #[test]
    fn test_cover_crypt() -> Result<()> {
        // user groups
        let S = vec![HashSet::from([1, 2]), HashSet::from([3, 4])];
        // target set
        let T = HashSet::from([1, 2]);
        // user IDs
        let uid1 = 1;
        let uid3 = 3;
        // secure random number generator
        let rng = Mutex::new(CsRng::new());
        // setup scheme
        let (msk, mpk) = setup(&rng, &S);
        // generate user private keys
        let sk1 = join(&msk, uid1, &S);
        let sk3 = join(&msk, uid3, &S);
        // ecapsulate for the target set
        let (K, E) = encaps(&rng, &mpk, &T, &S)?;
        // decapsulate for users 1 and 3
        let res1 = decaps(1, &sk1, &E, &T, &S)?;
        let res3 = decaps(3, &sk3, &E, &T, &S)?;
        eyre::ensure!(res3.is_none(), "User 3 shouldn't be able to decapsulate!");
        eyre::ensure!(Some(K) == res1, "Wrong decapsulation for user 1!");
        Ok(())
    }
}
