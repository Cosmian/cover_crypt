use crate::utils;
use cosmian_crypto_base::{
    asymmetric::{AsymmetricCrypto, KeyPair},
    hybrid_crypto::Kem,
    Error as CryptoError,
};
use rand_core::{CryptoRng, RngCore};
use std::{
    collections::{HashMap, HashSet},
    fmt::Debug,
    hash::Hash,
};
use thiserror::Error;

#[derive(Error, Debug)]
pub enum Error<A: Debug> {
    #[error("Unknown authorisation {auth:?}")]
    UnknownAuthorisation { auth: A },
    #[error("{err:?}")]
    CryptoError { err: CryptoError },
}

/// CovCrypt private keys are a set of KEM private keys.
pub type PrivateKey<A, KEM> =
    HashMap<A, <<KEM as AsymmetricCrypto>::KeyPair as KeyPair>::PrivateKey>;

/// CovCrypt public keys are a set of KEM public keys.
pub type PublicKey<A, KEM> = HashMap<A, <<KEM as AsymmetricCrypto>::KeyPair as KeyPair>::PublicKey>;

/// CovCrypt ciphertexts are a list of secret key / encapsulation couples
/// generated by the underlying KEM scheme.
pub type Encapsulation<A> = HashMap<A, (Vec<u8>, Vec<u8>)>;

/// CovCrypt secret key is a vector of bytes of the same length as secret key
/// of the underlying KEM.
pub type SecretKey = Vec<u8>;

/// Generate the master private key and master public key of the CoverCrypt scheme.
///
/// - `n`   : number of authorisation groups
///
/// Setup : `λ → (msk,mpk)`
///  - takes the security parameter (number of security bits we would like to
/// reach).
///
/// It first defines the partition of subsets Sᵢ that covers the set S
/// with respect to the target users’ rights.
///
/// And for each Sᵢ, it invokes (`KEM.KeyGen` which outputs `(pkᵢ,skᵢ)` and
/// defines `mpk = (pkᵢ)ᵢ` and `msk = (skᵢ)ᵢ` the master public key and master
/// secret key.
pub fn setup<A, R, KEM>(rng: &mut R, S: &HashSet<A>) -> (PrivateKey<A, KEM>, PublicKey<A, KEM>)
where
    A: Clone + Eq + Hash + Debug,
    R: CryptoRng + RngCore,
    KEM: Kem,
{
    let (mut msk, mut mpk) = (
        HashMap::with_capacity(S.len()),
        HashMap::with_capacity(S.len()),
    );
    for authorisation in S.iter() {
        let keypair = KEM::key_gen(rng);
        msk.insert(authorisation.to_owned(), keypair.private_key().to_owned());
        mpk.insert(authorisation.to_owned(), keypair.public_key().to_owned());
    }
    (msk, mpk)
}

/// Generate a user private key for a given list of user groups. It is composed
/// by the list of the KEM private keys associated with the user groups
/// containing the given user ID.
///
/// - `msk` : master secret key
/// - `U`   : user authorisations
pub fn join<A, KEM>(
    msk: &PrivateKey<A, KEM>,
    U: &HashSet<A>,
) -> Result<PrivateKey<A, KEM>, Error<A>>
where
    A: Clone + Eq + Hash + Debug,
    KEM: Kem,
{
    let mut sk_u = HashMap::with_capacity(U.len());
    for authorisation in U.iter() {
        match msk.get(authorisation) {
            Some(key) => Ok(sk_u.insert(authorisation.to_owned(), key.to_owned())),
            None => Err(Error::UnknownAuthorisation {
                auth: authorisation.to_owned(),
            }),
        }?;
    }
    Ok(sk_u)
}

/// Generate the secret key and its encapsulation.
///
/// - `rng` : secure random number generator
/// - `mpk` : master public key
/// - `T`   : target groups
/// - `S`   : user groups
pub fn encaps<A, R, KEM>(
    rng: &mut R,
    mpk: &PublicKey<A, KEM>,
    T: &HashSet<A>,
) -> Result<(SecretKey, Encapsulation<A>), Error<A>>
where
    A: Clone + Eq + Hash + Debug,
    R: CryptoRng + RngCore,
    KEM: Kem,
{
    // secret key
    let K = utils::generate_random_bytes(rng, KEM::SECRET_KEY_LENGTH);

    // construct secret key encapsulation
    let mut E = HashMap::with_capacity(T.len());
    for authorisation in T.iter() {
        match mpk.get(authorisation) {
            Some(pk) => {
                let (K_i, E_i) = KEM::encaps(rng, pk).map_err(|err| Error::CryptoError { err })?;
                E.insert(
                    authorisation.to_owned(),
                    (
                        K_i.iter().zip(K.iter()).map(|(e1, e2)| e1 ^ e2).collect(),
                        E_i,
                    ),
                );
                Ok(())
            }
            None => Err(Error::UnknownAuthorisation {
                auth: authorisation.to_owned(),
            }),
        }?;
    }

    Ok((K, E))
}

/// Decapsulate the secret key if the given user ID is in the target set.
///
/// - `uid`     : user ID
/// - `sk_u`    : user private key
/// - `E`       : encapsulation
/// - `T`       : target set
/// - `S`       : list of all user groups
pub fn decaps<A, KEM>(
    sk_u: &PrivateKey<A, KEM>,
    E: &Encapsulation<A>,
) -> Result<Option<SecretKey>, Error<A>>
where
    A: Clone + Eq + Hash + Debug,
    KEM: Kem,
{
    for (authorisation, (Ki_1, E_i)) in E.iter() {
        if let Some(sk) = sk_u.get(authorisation) {
            let Ki_2 = KEM::decaps(sk, E_i).map_err(|err| Error::CryptoError { err })?;

            // XOR the two `K_i`
            let K = Ki_1
                .iter()
                .zip(Ki_2.iter())
                .map(|(e1, e2)| e1 ^ e2)
                .collect();
            return Ok(Some(K));
        }
    }
    Ok(None)
}

#[cfg(test)]
mod tests {
    use super::*;
    use cosmian_crypto_base::asymmetric::ristretto::X25519Crypto;
    use cosmian_crypto_base::entropy::CsRng;
    use eyre::Result;

    #[test]
    fn test_cover_crypt() -> Result<()> {
        // authorisation list
        let S = HashSet::from(["admin", "dev"]);
        // user list
        let U = vec![HashSet::from(["dev"]), HashSet::from(["admin", "dev"])];
        // target set
        let T = HashSet::from(["admin"]);
        // secure random number generator
        let mut rng = CsRng::new();
        // setup scheme
        let (msk, mpk) = setup::<_, _, X25519Crypto>(&mut rng, &S);
        // generate user private keys
        let sk0 = join::<_, X25519Crypto>(&msk, &U[0])?;
        let sk1 = join::<_, X25519Crypto>(&msk, &U[1])?;
        // encapsulate for the target set
        let (K, E) = encaps::<_, _, X25519Crypto>(&mut rng, &mpk, &T)?;
        // decapsulate for users 1 and 3
        let res0 = decaps::<_, X25519Crypto>(&sk0, &E)?;
        let res1 = decaps::<_, X25519Crypto>(&sk1, &E)?;
        eyre::ensure!(res0.is_none(), "User 0 shouldn't be able to decapsulate!");
        eyre::ensure!(Some(K) == res1, "Wrong decapsulation for user 1!");
        Ok(())
    }
}
